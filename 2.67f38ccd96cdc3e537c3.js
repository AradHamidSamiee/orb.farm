(window.webpackJsonp=window.webpackJsonp||[]).push([[2],{1:function(n,e,t){"use strict";t.r(e);var a=t(3),o=t(5);function i(n){return function(n){if(Array.isArray(n)){for(var e=0,t=new Array(n.length);e<n.length;e++)t[e]=n[e];return t}}(n)||function(n){if(Symbol.iterator in Object(n)||"[object Arguments]"===Object.prototype.toString.call(n))return Array.from(n)}(n)||function(){throw new TypeError("Invalid attempt to spread non-iterable instance")}()}var r=t(16);window.memory=o.d;var s=t(17),c=t(18),l=function(n){var e=n.canvas,t=n.universe,a=n.isSnapshot,i=void 0!==a&&a,l=r({canvas:e,attributes:{preserveDrawingBuffer:i}}),m=t.width(),u=t.height(),d=t.cells(),f=t.lights(),h=new Uint8Array(o.d.buffer,d,m*u*4),v=new Uint8Array(o.d.buffer,f,m*u*4),p=l.texture({width:m,height:u,data:h}),x=l.texture({width:m,height:u,data:v}),y=l({blend:{enable:!0,func:{srcRGB:"src alpha",srcAlpha:1,dstRGB:"one minus src alpha",dstAlpha:1},equation:{rgb:"add",alpha:"add"},color:[0,0,0,0]},frag:s,uniforms:{t:function(n){return n.tick},data:function(){return d=t.cells(),h=new Uint8Array(o.d.buffer,d,m*u*4),p({width:m,height:u,data:h})},light:function(){return f=t.lights(),v=new Uint8Array(o.d.buffer,f,m*u*4),x({width:m,height:u,data:v})},resolution:function(n){return[n.viewportWidth,n.viewportHeight]},dpi:2*window.devicePixelRatio,isSnapshot:i},vert:c,attributes:{position:[[-1,4],[-1,-1],[4,-1]]},count:3});return function(){l.poll(),y()}};function m(n,e){for(var t=0;t<e.length;t++){var a=e[t];a.enumerable=a.enumerable||!1,a.configurable=!0,"value"in a&&(a.writable=!0),Object.defineProperty(n,a.key,a)}}var u=new(function(){function n(){!function(n,e){if(!(n instanceof e))throw new TypeError("Cannot call a class as a function")}(this,n),this.fps=document.getElementById("fps"),this.frames=[],this.lastFrameTimeStamp=performance.now()}var e,t,a;return e=n,(t=[{key:"render",value:function(){var n=performance.now(),e=n-this.lastFrameTimeStamp;this.lastFrameTimeStamp=n;var t=1/e*1e3;this.frames.push(t),this.frames.length>30&&this.frames.shift();for(var a=1/0,o=-1/0,i=0,r=0;r<this.frames.length;r++)i+=this.frames[r],a=Math.min(this.frames[r],a),o=Math.max(this.frames[r],o);var s=i/this.frames.length;this.fps.textContent="FPS:".concat(Math.round(s),"\n    O2: ").concat(window.u.O2(),"\n    CO2: ").concat(window.u.CO2(),"\n    ")}}])&&m(e.prototype,t),a&&m(e,a),n}()),d=t(2),f=t.n(d),h=t(6),v=function(n){var e=n.close,t=n.children;return f.a.createElement("div",{className:"menu-scrim"},f.a.createElement("div",{className:"menu"},t,f.a.createElement(h.b,{to:"/",className:"x",onClick:e},f.a.createElement("button",null," x"))))};function p(n){return(p="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(n){return typeof n}:function(n){return n&&"function"==typeof Symbol&&n.constructor===Symbol&&n!==Symbol.prototype?"symbol":typeof n})(n)}function x(n,e){for(var t=0;t<e.length;t++){var a=e[t];a.enumerable=a.enumerable||!1,a.configurable=!0,"value"in a&&(a.writable=!0),Object.defineProperty(n,a.key,a)}}function y(n){return(y=Object.setPrototypeOf?Object.getPrototypeOf:function(n){return n.__proto__||Object.getPrototypeOf(n)})(n)}function g(n){if(void 0===n)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return n}function w(n,e){return(w=Object.setPrototypeOf||function(n,e){return n.__proto__=e,n})(n,e)}window.species=a.a;var b=function(){var n=document.createElement("canvas"),e=Object.values(a.a),t=Math.max.apply(Math,i(e))+1,o=a.b.new(t,1);n.width=t,n.height=3,o.reset(),e.forEach(function(n){return o.paint(n,0,2,n)}),l({universe:o,canvas:n,isSnapshot:!0})();var r=n.getContext("webgl"),s=new Uint8Array(4*t);r.readPixels(0,0,t,1,r.RGBA,r.UNSIGNED_BYTE,s);var c={};return e.forEach(function(n){var e=4*n,t="rgba(".concat(s[e],",").concat(s[e+1],", ").concat(s[e+2],", 1.0)");c[n]=t}),c}(),z=[2,5,10],_=function(n){function e(n){var t,o,i;return function(n,e){if(!(n instanceof e))throw new TypeError("Cannot call a class as a function")}(this,e),o=this,(t=!(i=y(e).call(this,n))||"object"!==p(i)&&"function"!=typeof i?g(o):i).state={submissionMenuOpen:!1,paused:!1,submitting:!1,size:1,dataURL:{},currentSubmission:null,selectedElement:a.a.Water},window.UI=g(t),t.load(),t}var t,i,r;return function(n,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");n.prototype=Object.create(e&&e.prototype,{constructor:{value:n,writable:!0,configurable:!0}}),e&&w(n,e)}(e,f.a.Component),t=e,(i=[{key:"componentDidUpdate",value:function(n){}},{key:"togglePause",value:function(){window.paused=!this.state.paused,this.setState({paused:!this.state.paused})}},{key:"play",value:function(){window.paused=!1,this.setState({paused:!1})}},{key:"pause",value:function(){window.paused=!0,this.setState({paused:!0})}},{key:"setSize",value:function(n,e){n.preventDefault(),this.setState({size:e})}},{key:"reset",value:function(){window.confirm("Reset?")&&(this.play(),this.setState({currentSubmission:null}),cn())}},{key:"menu",value:function(){this.pause(),this.setState({submissionMenuOpen:!0})}},{key:"closeMenu",value:function(){this.play(),this.setState({submissionMenuOpen:!1})}},{key:"upload",value:function(){var n=function(n){var e=document.createElement("canvas");return e.width=n.width()/2,e.height=n.height()/2,l({universe:n,canvas:e,isSnapshot:!0})(),e.toDataURL("image/png")}(V),e=new Uint8Array(o.d.buffer,V.cells(),J*Q*4),t=document.createElement("canvas"),a=t.getContext("2d"),i=a.createImageData(J,Q);t.height=Q,t.width=J;for(var r=0;r<J*Q*4;r++)i.data[r]=r%4==3?255:e[r];a.putImageData(i,0,0);var s=t.toDataURL("image/png");this.pause(),this.setState({data:{dataURL:n,cells:s},submissionMenuOpen:!0})}},{key:"load",value:function(){var n=this,e=this.props.location.hash.replace(/#/,"");""!==e&&(this.state.currentSubmission&&this.state.currentSubmission.id==e||fetch(functions._url("api/creations/".concat(e)),{method:"GET",headers:{"Content-Type":"application/json"}}).then(function(n){return n.json()}).then(function(t){storage.refFromURL("gs://sandtable-8d0f7.appspot.com/creations/".concat(t.id,".data.png")).getDownloadURL().then(function(a){fetch(a,{method:"GET"}).then(function(n){return n.blob()}).then(function(a){n.setState({currentSubmission:{id:e,data:t}});var i=URL.createObjectURL(a),r=new Image;r.src=i,r.onload=function(){var e=document.createElement("canvas");e.width=J,e.height=Q;var t=e.getContext("2d");t.drawImage(r,0,0);var a=t.getImageData(0,0,e.width,e.height),i=new Uint8Array(o.d.buffer,V.cells(),J*Q*4);cn();for(var s=0;s<J*Q*4;s++)i[s]=a.data[s];V.flush_undos(),V.push_undo(),n.pause()}}).catch(function(n){return console.error("Error:",n)})})}).catch(function(n){console.error("Error:",n)}))}},{key:"render",value:function(){var n=this,e=this.state,t=e.size,o=e.paused,i=e.selectedElement,r=e.currentSubmission,s=r&&r.id?"#".concat(r.id):"";return f.a.createElement(f.a.Fragment,null,f.a.createElement("button",{onClick:function(){return n.togglePause()},className:o?"selected":""},o?f.a.createElement("svg",{height:"20",width:"20",id:"d",viewBox:"0 0 300 300"},f.a.createElement("polygon",{id:"play",points:"0,0 , 300,150 0,300"})):f.a.createElement("svg",{height:"20",width:"20",id:"d",viewBox:"0 0 300 300"},f.a.createElement("polygon",{id:"bar2",points:"0,0 110,0 110,300 0,300"}),f.a.createElement("polygon",{id:"bar1",points:"190,0 300,0 300,300 190,300"}))),f.a.createElement("button",{onClick:function(){return n.reset()}},"Reset"),f.a.createElement(h.b,{to:{pathname:"/info/",hash:s}},f.a.createElement("button",null,"Info")),f.a.createElement("span",{className:"sizes"},z.map(function(e,a){return f.a.createElement("button",{key:a,className:a==t?"selected":"",onClick:function(e){return n.setSize(e,a)},style:{padding:"0px"}},f.a.createElement("svg",{height:"23",width:"23",id:"d",viewBox:"0 0 100 100"},f.a.createElement("circle",{cx:"50",cy:"50",r:2+3*e})))})),f.a.createElement("button",{onClick:function(){cn(),V.pop_undo()},style:{fontSize:35}},"↜"),Object.keys(a.a).filter(function(n){return!["Plant","FishTail"].includes(n)}).map(function(e){return function(n,e,t){var o=a.a[n],i=b[o],r=o==e;return f.a.createElement("button",{className:r?"selected":"",key:n,onClick:function(){t(o)},style:{background:"inherit",backgroundColor:i,filter:r||"saturate(0.5) "}},"  ",n,"  ")}(e,i,function(e){return n.setState({selectedElement:e})})}),this.state.currentSubmission&&f.a.createElement("div",{className:"submission-title"},f.a.createElement("button",{onClick:function(){return n.incScore()}},"+♡",this.state.currentSubmission.data.score," "),this.state.currentSubmission.data.title),this.state.submissionMenuOpen&&f.a.createElement(v,{close:function(){return n.closeMenu()}},f.a.createElement("h4",null,"Share your creation with the people!"),f.a.createElement("img",{src:this.state.data.dataURL,className:"submissionImg"}),f.a.createElement("div",{style:{display:"flex"}},f.a.createElement("input",{placeholder:"title",onChange:function(e){return n.setState({title:e.target.value})}}),f.a.createElement("button",{disabled:this.state.submitting,onClick:function(){return n.submit()}},"Submit"))))}}])&&x(t.prototype,i),r&&x(t,r),e}(),E=document.getElementById("sand-canvas"),S=function(n,e){return Math.sqrt(Math.pow(n.clientX-e.clientX,2)+Math.pow(n.clientY-e.clientY,2),2)},k=function(n){var e=function(n){return Math.sqrt(Math.pow(n.clientX,2)+Math.pow(n.clientY,2),2)}(n);return{clientX:n.clientX/e,clientY:n.clientY/e}},R=function(n,e){return{clientX:n.clientX*e,clientY:n.clientY*e}},A=function(n,e){return{clientX:n.clientX+e.clientX,clientY:n.clientY+e.clientY}},D=function(n,e){return{clientX:n.clientX-e.clientX,clientY:n.clientY-e.clientY}},M=!1,T=null,I=null;function C(n){clearInterval(I),I=window.setInterval(function(){return O(n)},100);var e={clientX:n.clientX,clientY:n.clientY};if(M){var t=z[window.UI.state.size],a=0;if(O(e),T)for(;S(e,T)>t/3;){var o=S(e,T);if(e=A(e,R(k(D(T,n)),Math.min(t/3,o))),++a>1e3)break;O(e)}T=n}}E.addEventListener("mousedown",function(n){n.preventDefault(),V.push_undo(),M=!0,clearInterval(I),I=window.setInterval(function(){return O(n)},100),O(n),T=n}),document.body.addEventListener("mouseup",function(n){clearInterval(I),M&&(n.preventDefault(),T=null,M=!1)}),E.addEventListener("mousemove",function(n){clearInterval(I),C(n)}),E.addEventListener("mouseleave",function(n){clearInterval(I),T=null}),E.addEventListener("touchstart",function(n){V.push_undo(),n.cancelable&&n.preventDefault(),M=!0,T=n,L(n)}),E.addEventListener("touchend",function(n){n.cancelable&&n.preventDefault(),T=null,M=!1,clearInterval(I)}),E.addEventListener("touchmove",function(n){window.paused||n.cancelable&&n.preventDefault(),clearInterval(I),L(n)});var L=function(n){var e=Array.from(n.touches);1==e.length?C(e[0]):e.forEach(O)},O=function(n){if(M){var e=E.getBoundingClientRect(),t=E.width/(Z*Math.ceil(window.devicePixelRatio))/e.width,a=E.height/(Z*Math.ceil(window.devicePixelRatio))/e.height,o=(n.clientX-e.left)*t,i=(n.clientY-e.top)*a,r=Math.min(Math.floor(o),J-1),s=Math.min(Math.floor(i),Q-1);window.UI.state.selectedElement<0||V.paint(r,s,z[window.UI.state.size],window.UI.state.selectedElement)}},U=t(29),P=t.n(U),N=t(10),F=function(){return f.a.createElement("div",{className:"Info"},f.a.createElement("h1",null,"A sealed ecosystem simulation "),f.a.createElement("p",null,"Created by ",f.a.createElement("a",{href:"https://maxbittker.com"},"max bittker")),"forked from sandspiel")};function B(n){n.match;var e=n.location;return f.a.createElement(v,null,f.a.createElement(Browse,{location:e}))}function G(n){n.match;var e=n.location;return f.a.createElement(v,null,f.a.createElement(Admin,{location:e}))}function j(n){n.match;var e=n.location;return f.a.createElement(v,null,f.a.createElement(SignInScreen,{location:e}))}P.a.render(f.a.createElement(function(){return f.a.createElement(h.a,null,f.a.createElement(N.a,{path:"/",component:_}),f.a.createElement(N.a,{exact:!0,path:"/info/",component:function(){return f.a.createElement(v,null,f.a.createElement(F,null))}}),f.a.createElement(N.a,{path:"/browse",component:B}),f.a.createElement(N.a,{path:"/admin",component:G}),f.a.createElement(N.a,{path:"/login",component:j}),f.a.createElement(N.a,{path:"/__/auth/handler",component:j}))},null),document.getElementById("ui"));t(33);function X(n,e){for(var t=0;t<e.length;t++){var a=e[t];a.enumerable=a.enumerable||!1,a.configurable=!0,"value"in a&&(a.writable=!0),Object.defineProperty(n,a.key,a)}}var Y=t(34),H=function(){function n(e,t){!function(n,e){if(!(n instanceof e))throw new TypeError("Cannot call a class as a function")}(this,n),this.canvas=document.getElementById(e),this.gl=this.canvas.getContext("webgl"),this.textures={};var a,o,i="";!(this.gl instanceof WebGLRenderingContext)?(a=!0,o=!0):(a=this.gl.getExtension("OES_standard_derivatives"),o=this.gl.getExtension("EXT_shader_texture_lod")),o&&(i+="#extension GL_EXT_shader_texture_lod : enable\n"),a&&(i+="#ifdef GL_OES_standard_derivatives\n#extension GL_OES_standard_derivatives : enable\n#endif\n"),i+=Y,this.shader=n.linkShader(this.gl,"attribute vec4 aPosition; void main() { gl_Position = aPosition; } ",i),this.shader.vertexAttribute=this.gl.getAttribLocation(this.shader,"aPosition"),this.gl.enableVertexAttribArray(this.shader.vertexAttribute),this.height=window.innerHeight/t,this.width=window.innerWidth/t,this.canvas.setAttribute("width",this.width),this.canvas.setAttribute("height",this.height),this.vertexBuffer=n.createVBO(this.gl,3,[1,1,0,-1,1,0,1,-1,0,-1,-1,0]),this.running=!1,this.time0=0}var e,t,a;return e=n,a=[{key:"createVBO",value:function(n,e,t){var a=n.createBuffer();return n.bindBuffer(n.ARRAY_BUFFER,a),n.bufferData(n.ARRAY_BUFFER,new Float32Array(t),n.STATIC_DRAW),a.itemSize=e,a.numItems=t.length/e,a}},{key:"linkShader",value:function(e,t,a){var o=e.createProgram();if(e.attachShader(o,n.compileShader(e,e.VERTEX_SHADER,t)),e.attachShader(o,n.compileShader(e,e.FRAGMENT_SHADER,a)),e.linkProgram(o),!e.getProgramParameter(o,e.LINK_STATUS))throw n.showLog(e,o),"Failed to link shader!";return o.uniformLocation=function(n,e){return n.getUniformLocation(o,e)},o}},{key:"compileShader",value:function(e,t,a){var o=e.createShader(t);if(e.shaderSource(o,a),e.compileShader(o),!e.getShaderParameter(o,e.COMPILE_STATUS)){var i=t==e.VERTEX_SHADER?"vertex shader":"fragment shader";throw n.showLog(e,o),"Failed to compile ".concat(i)}return o}},{key:"getTime",value:function(){return.001*(new Date).getTime()}},{key:"showLog",value:function(n,e){var t=n.getShaderInfoLog(e);console.log("ERROR: "+t)}}],(t=[{key:"loadTexture",value:function(n,e){var t=this,a=this.gl.createTexture(),o=this.gl;a.image=new Image,a.image.onload=function(){o.bindTexture(o.TEXTURE_2D,a),o.pixelStorei(o.UNPACK_FLIP_Y_WEBGL,!0);try{o.texImage2D(o.TEXTURE_2D,0,o.RGBA,o.RGBA,o.UNSIGNED_BYTE,a.image)}catch(n){console.log("ERROR: Failed to load texture ".concat(e," : ").concat(n)),console.log("INFO: Generating placeholder texture for ".concat(e));for(var i=[],r=0;r<64;r++)for(var s=0;s<64;s++){var c=(parseInt(s/4)+parseInt(r/4))%2*255;i=i.concat([c,c,c,255])}o.texImage2D(o.TEXTURE_2D,0,o.RGBA,64,64,0,o.RGBA,o.UNSIGNED_BYTE,new Uint8Array(i))}o.texParameteri(o.TEXTURE_2D,o.TEXTURE_MAG_FILTER,o.LINEAR),o.texParameteri(o.TEXTURE_2D,o.TEXTURE_MIN_FILTER,o.LINEAR),o.bindTexture(o.TEXTURE_2D,null),t.textures[n]=a},a.image.src=e}},{key:"start",value:function(){this.running||this._start()}},{key:"_start",value:function(){this.running=!0,this.time0=n.getTime(),this.timePreviousFrame=this.time0,this.gl.disable(this.gl.DEPTH_TEST),this.gl.viewport(0,0,this.width,this.height),this.gl.useProgram(this.shader)}},{key:"stop",value:function(){this.running=!1}},{key:"frame",value:function(e){var t=this.gl;if(this.running){var a=this.shader,o=n.getTime()-this.time0;for(var i in this.timePreviousFrame,this.timePreviousFrame=o,t.clear(t.DEPTH_BUFFER_BIT),t.bindBuffer(t.ARRAY_BUFFER,this.vertexBuffer),t.vertexAttribPointer(a.vertexAttribute,this.vertexBuffer.itemSize,t.FLOAT,!1,0,0),this.textures){var r=this.textures[i];t.activeTexture(t.TEXTURE0+parseInt(i)),t.bindTexture(t.TEXTURE_2D,r),t.uniform1i(t.getUniformLocation(a,"iChannel"+i),i)}t.uniform3f(t.getUniformLocation(a,"iResolution"),this.width,this.height,0),t.uniform1f(t.getUniformLocation(a,"iGlobalTime"),o),t.uniform1f(t.getUniformLocation(a,"iTime"),o),t.uniform1f(t.getUniformLocation(a,"gameTime"),e),t.drawArrays(t.TRIANGLE_STRIP,0,this.vertexBuffer.numItems)}}}])&&X(e.prototype,t),a&&X(e,a),n}();t.d(e,"canvas",function(){return $}),t.d(e,"width",function(){return J}),t.d(e,"height",function(){return Q}),t.d(e,"ratio",function(){return Z}),t.d(e,"universe",function(){return V}),t.d(e,"reset",function(){return cn});var q=200,W=100,V=a.b.new(q,q);V.paint(W,W,196,a.a.Glass),V.paint(70,191,20,a.a.Wood),V.paint(130,191,20,a.a.Wood),V.paint(W,W,192,a.a.Air);for(var K=30;K<164;K+=10)V.paint(K,120,W,a.a.Water);for(K=0;K<194;K+=10)V.paint(K,145.5,20,a.a.Sand);V.paint(W,W,1.1*W,a.a.Water),V.paint(W,W,2,a.a.Zoop),V.paint(120,W,2,a.a.Fish),V.paint(W,120,2,a.a.Bacteria),V.paint(150,120,2,a.a.Seed),V.paint(W,W,10,a.a.Algae);var Z=2,J=q,Q=q,$=document.getElementById("sand-canvas");$.height=q*Z*Math.ceil(window.devicePixelRatio),$.width=q*Z*Math.ceil(window.devicePixelRatio);var nn,en=document.getElementById("ui"),tn=function(){var n=window.innerWidth,e="",t="";n>window.innerHeight-50?n-window.innerHeight<400?(e="height: ".concat(window.innerHeight,"px; margin:3px"),nn=window.innerHeight,t="width: ".concat(n-window.innerHeight-12,"px; margin: 2px;")):(e="height: ".concat(window.innerHeight,"px"),nn=window.innerHeight,t="width: ".concat((n-window.innerHeight)/2-7,"px; margin: 2px;")):(nn=n,e="width: ".concat(n,"px; "),t=""),en.style=t,$.style=e};tn(),window.addEventListener("deviceorientation",tn,!0),window.addEventListener("resize",tn);var an,on=l({canvas:$,universe:V}),rn=((an=new H("sky-canvas",2*(nn/q))).loadTexture(0,"assets/noise.png"),an.start(),an),sn=0;function cn(){V.reset()}window.u=V,window.universe=V,function n(){window.paused||(u.render(),V.tick()),V.set_time(sn%255),on(),rn.frame(sn/255),sn+=.1,window.animWebationId=requestAnimationFrame(n)}()},17:function(n,e){n.exports="precision highp float;\n#define GLSLIFY 1\nuniform float t;\nuniform float dpi;\nuniform vec2 resolution;\nuniform bool isSnapshot;\nuniform sampler2D backBuffer;\nuniform sampler2D data;\nuniform sampler2D light;\n\nvarying vec2 uv;\n\n// clang-format off\nvec3 hsv2rgb_3_0(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\n\n//\n// Description : Array and textureless GLSL 2D/3D/4D simplex\n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289_1_1(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289_1_1(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute_1_2(vec4 x) {\n     return mod289_1_1(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt_1_3(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise_1_4(vec3 v)\n  {\n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D_1_5 = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g_1_6 = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g_1_6;\n  vec3 i1 = min( g_1_6.xyz, l.zxy );\n  vec3 i2 = max( g_1_6.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D_1_5.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n  i = mod289_1_1(i);\n  vec4 p = permute_1_2( permute_1_2( permute_1_2(\n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D_1_5.wyz - D_1_5.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1_1_7 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0_1_8 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1_1_7.xy,h.z);\n  vec3 p3 = vec3(a1_1_7.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt_1_3(vec4(dot(p0_1_8,p0_1_8), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0_1_8 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0_1_8,x0), dot(p1,x1),\n                                dot(p2,x2), dot(p3,x3) ) );\n  }\n\n\n\n//\n// Description : Array and textureless GLSL 2D simplex noise function.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289_2_9(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec2 mod289_2_9(vec2 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec3 permute_2_10(vec3 x) {\n  return mod289_2_9(((x*34.0)+1.0)*x);\n}\n\nfloat snoise_2_11(vec2 v)\n  {\n  const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                      0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                     -0.577350269189626,  // -1.0 + 2.0 * C.x\n                      0.024390243902439); // 1.0 / 41.0\n// First corner\n  vec2 i  = floor(v + dot(v, C.yy) );\n  vec2 x0 = v -   i + dot(i, C.xx);\n\n// Other corners\n  vec2 i1;\n  //i1.x = step( x0.y, x0.x ); // x0.x > x0.y ? 1.0 : 0.0\n  //i1.y = 1.0 - i1.x;\n  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n  // x0 = x0 - 0.0 + 0.0 * C.xx ;\n  // x1 = x0 - i1 + 1.0 * C.xx ;\n  // x2 = x0 - 1.0 + 2.0 * C.xx ;\n  vec4 x12 = x0.xyxy + C.xxzz;\n  x12.xy -= i1;\n\n// Permutations\n  i = mod289_2_9(i); // Avoid truncation effects in permutation\n  vec3 p = permute_2_10( permute_2_10( i.y + vec3(0.0, i1.y, 1.0 ))\n    + i.x + vec3(0.0, i1.x, 1.0 ));\n\n  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n  m = m*m ;\n  m = m*m ;\n\n// Gradients: 41 points uniformly over a line, mapped onto a diamond.\n// The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)\n\n  vec3 x = 2.0 * fract(p * C.www) - 1.0;\n  vec3 h = abs(x) - 0.5;\n  vec3 ox = floor(x + 0.5);\n  vec3 a0 = x - ox;\n\n// Normalise gradients implicitly by scaling m\n// Approximation of: m *= inversesqrt( a0*a0 + h*h );\n  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n\n// Compute final noise value at P\n  vec3 g;\n  g.x  = a0.x  * x0.x  + h.x  * x0.y;\n  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n  return 130.0 * dot(m, g);\n}\n\n\n\nhighp float random_4_12(vec2 co)\n{\n    highp float a = 12.9898;\n    highp float b = 78.233;\n    highp float c = 43758.5453;\n    highp float dt= dot(co.xy ,vec2(a,b));\n    highp float sn= mod(dt,3.14);\n    return fract(sin(sn) * c);\n}\n\n\n\n// clang-format on\n\nvoid main() {\n  vec3 color;\n  vec2 grid = floor(uv * resolution / dpi);\n  //   float r = abs(sin(t / 25.));\n  //   if (length(uv) < r && length(uv) > r - 0.1) {\n  // color = hsv2rgb(vec3(sin(t * 0.01), 0.5, 0.5));\n  float noise = snoise_1_4(vec3(grid, t * 0.05));\n\n  vec2 textCoord = (uv * vec2(0.5, -0.5)) + vec2(0.5);\n  vec2 sampleCoord =\n      (uv * vec2(0.5, -0.5)) + vec2(0.5) + vec2(noise, 0.0) / resolution;\n  // vec3 bb = texture2D(backBuffer, (uv * 0.5) + vec2(0.5)).rgb;\n\n  vec4 data = texture2D(data, textCoord);\n  float lightValue = texture2D(light, textCoord).r;\n  float sampleLightValue = texture2D(light, sampleCoord).r;\n  lightValue = 0.5 * lightValue + 0.5 * sampleLightValue;\n  int type = int((data.r * 255.) + 0.1);\n  float energy = data.g;\n  float age = data.b;\n\n  float hue = 0.0;\n  float saturation = 0.6;\n  float lightness = 0.3 + energy * 0.5;\n  float a = 1.0;\n  float brightness = 0.0;\n\n  if (type == 0) { // Air\n\n    hue = 0.0;\n    saturation = 0.1;\n    lightness = 0.1;\n    a = 0.0;\n    if (isSnapshot) {\n      saturation = 0.05;\n      lightness = 1.01;\n      a = 1.0;\n    }\n\n  } else if (type == 1) { // Glass\n    hue = 0.1;\n    saturation = 0.1;\n    lightness = 0.5;\n  } else if (type == 2) { // Sand\n    hue =  0.1;\n    saturation = 0.4 + (age*0.2)  ;\n    lightness = 1.3 - energy;\n\n  } else if (type == 3) { // Water\n    hue = 0.58;\n    saturation = 0.6;\n    lightness = 0.5 + energy * 0.25 + noise * 0.1;\n    a = 0.4;\n    if (isSnapshot) {\n      a = 1.0;\n    }\n  } else if (type == 4) { // Algae\n    hue = 0.4 - age * 0.3;\n    lightness += 0.0;\n    saturation = 0.5 - (energy * .2);\n  } else if (type == 5) { // Plant\n    hue = 0.4;\n    lightness -= 0.1;\n    saturation = 0.4;\n  } else if (type == 6) { // Zoop\n    hue = 0.9;\n    lightness += 0.7;\n  } else if (type == 7) { // Fish\n    hue = 0.0;\n    lightness += 0.4;\n  } else if (type == 8) { // Bacteria\n    hue = 0.9;\n    saturation -= 0.2;\n    lightness -= 0.1;\n  } else if (type == 9) { // ???\n    hue = 0.6;\n    saturation = 0.4;\n    lightness = 0.7 + data.g * 0.5;\n  } else if (type == 10) { // Waste\n    hue = 0.9;\n    lightness -= 0.3;\n    saturation = 0.4;\n  } else if (type == 11) { // Seed\n    hue = 0.4;\n    saturation = 0.4;\n  } else if (type == 12) { // Stone\n    hue = -0.4 + (data.g * 0.5);\n    saturation = 0.1;\n  } else if (type == 13) { // Wood\n    hue = (data.g * 0.1);\n    saturation = 0.3;\n    lightness = 0.3 + data.g * 0.3;\n  } else if (type == 14) { // Egg\n    hue = 0.9;\n    saturation = age;\n    lightness = 1.0;\n  } else if (type == 15) { // Tail\n    hue += fract(age * 255.*1.2)*0.2;\n    lightness += 0.4;\n    // saturation += fract(age * 255.*6.);\n  }\n  //  else if (type == 15) { // mite\n\n  // } else if (type == 16) { // oil\n  //   hue = (data.g * 5.0) + t * .008;\n\n  //   saturation = 0.2;\n  //   lightness = 0.3;\n  // } else if (type == 17) { // Rocket\n  //   hue = 0.0;\n  //   saturation = 0.4 + data.b;\n  //   lightness = 0.9;\n  // } else if (type == 18) { // fungus\n  //   hue = (data.g * 0.15) - 0.1;\n  //   saturation = (data.g * 0.8) - 0.05;\n\n  //   // (data.g * 0.00);\n  //   lightness = 1.5 - (data.g * 0.2);\n  // } else if (type == 19) { // seed/flower\n\n  //   hue = fract(fract(data.b * 2.) * 0.5) - 0.3;\n  //   saturation = 0.7 * (data.g + 0.4) + data.b * 0.2;\n  //   lightness = 0.9 * (data.g + 0.9);\n  // }\n  if (isSnapshot == false) {\n    lightness *= (0.975 + snoise_2_11(floor(uv * resolution / dpi)) * 0.025);\n  }\n  lightness += lightValue / 2.;\n  saturation = min(saturation, 1.0);\n  lightness = min(lightness, 1.0);\n  color = hsv2rgb_3_0(vec3(hue, saturation, lightness));\n  gl_FragColor = vec4(color, a);\n}"},18:function(n,e){n.exports='\n// boring "pass-through" vertex shader\nprecision mediump float;\n#define GLSLIFY 1\nattribute vec2 position;\nvarying vec2 uv;\nvoid main() {\n  uv = position;\n  gl_Position = vec4(position, 0, 1);\n}'},3:function(n,e,t){"use strict";t.d(e,"a",function(){return u}),t.d(e,"b",function(){return d}),t.d(e,"c",function(){return f}),t.d(e,"d",function(){return h});var a=t(5);function o(n,e){if(!(n instanceof e))throw new TypeError("Cannot call a class as a function")}function i(n,e){for(var t=0;t<e.length;t++){var a=e[t];a.enumerable=a.enumerable||!1,a.configurable=!0,"value"in a&&(a.writable=!0),Object.defineProperty(n,a.key,a)}}function r(n,e,t){return e&&i(n.prototype,e),t&&i(n,t),n}var s=new TextDecoder("utf-8"),c=null;function l(n,e){return s.decode((null!==c&&c.buffer===a.d.buffer||(c=new Uint8Array(a.d.buffer)),c).subarray(n,n+e))}var m,u=Object.freeze({Air:0,Glass:1,Sand:2,Water:3,Algae:4,Plant:5,Zoop:6,Egg:14,Fish:7,FishTail:15,Bacteria:8,Nitrogen:9,Waste:10,Seed:11,Stone:12,Wood:13}),d=function(){function n(){o(this,n)}return r(n,[{key:"free",value:function(){var n=this.ptr;this.ptr=0,a.c(n)}},{key:"reset",value:function(){a.r(this.ptr)}},{key:"calculate_light",value:function(){a.g(this.ptr)}},{key:"cast_ray",value:function(n,e,t,o,i){a.h(this.ptr,n,e,t,o,i)}},{key:"tick",value:function(){a.t(this.ptr)}},{key:"width",value:function(){return a.u(this.ptr)}},{key:"height",value:function(){return a.k(this.ptr)}},{key:"O2",value:function(){return a.f(this.ptr)>>>0}},{key:"CO2",value:function(){return a.e(this.ptr)>>>0}},{key:"cells",value:function(){return a.i(this.ptr)}},{key:"lights",value:function(){return a.m(this.ptr)}},{key:"paint",value:function(n,e,t,o){a.o(this.ptr,n,e,t,o)}},{key:"push_undo",value:function(){a.q(this.ptr)}},{key:"pop_undo",value:function(){a.p(this.ptr)}},{key:"flush_undos",value:function(){a.j(this.ptr)}},{key:"set_time",value:function(n){a.s(this.ptr,n)}},{key:"inc_time",value:function(){a.l(this.ptr)}}],[{key:"__wrap",value:function(e){var t=Object.create(n.prototype);return t.ptr=e,t}},{key:"new",value:function(e,t){var o=a.n(e,t);return n.__wrap(o)}}]),n}(),f="function"==typeof Math.random?Math.random:(m="Math.random",function(){throw new Error("".concat(m," is not defined"))}),h=function(n,e){throw new Error(l(n,e))}},33:function(n,e){var t,a;window.safari&&(history.pushState(null,null,location.href),window.onpopstate=function(n){history.go(1)}),a=!1,t=navigator.userAgent||navigator.vendor||window.opera,(/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino|android|ipad|playbook|silk/i.test(t)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(t.substr(0,4)))&&(a=!0),a&&(window.onbeforeunload=function(){return!0}),document.getElementById("background").addEventListener("touchmove",function(n){window.paused||n.cancelable&&n.preventDefault()})},34:function(n,e){n.exports="\n// clang-format off\n\n\n#ifdef GL_ES\nprecision highp float;\nprecision highp int;\n#define GLSLIFY 1\n#endif\n\nuniform vec3 iResolution;\nuniform float iGlobalTime, iTime, gameTime;\nuniform sampler2D iChannel0;\n// Appropriated with love from:///\n// The sun, the sky and the clouds. By StillTravelling\n// https://www.shadertoy.com/view/tdSXzD\n// Very much a messy hack sorry!!\n\n// Many Thank yous go to the below for their amazing work\n// Day and night sky cycle. By László Matuska (@BitOfGold)\n// Creates a sky texture for a skydome\n// https://www.shadertoy.com/view/ltlSWB\n\n// Weather. By David Hoskins, May 2014.\n// https://www.shadertoy.com/view/4dsXWn\n\n// Edge of atmosphere\n// created by dmytro rubalskyi (ruba)\n// https://www.shadertoy.com/view/XlXGzB\n\n// Auroras\n// created by nimitz\n// https://www.shadertoy.com/view/XtGGRt\n\n// Sorry to those I've missed out!!\n\n#define ORIG_CLOUD 0\n#define ENABLE_RAIN 0 // enable rain drops on screen\n#define SIMPLE_SUN 0\n#define NICE_HACK_SUN 1\n#define SOFT_SUN 1\n#define cloudy 0.5 // 0.0 clear sky\n#define haze 0.01 * (cloudy * 20.)\n#define rainmulti 5.0 // makes clouds thicker\n#define rainy (10.0 - rainmulti)\n#define t iTime\n#define fov tan(radians(60.0))\n#define S(x, y, z) smoothstep(x, y, z)\n#define cameraheight 5e1   // 50.\n#define mincloudheight 5e3 // 5e3\n#define maxcloudheight 8e3 // 8e3\n#define xaxiscloud t * 5e2 // t*5e2 +t left -t right *speed\n#define yaxiscloud 0.      // 0.\n#define zaxiscloud t * 6e2 // t*6e2 +t away from horizon -t towards horizon *speed\n#define cloudnoise 2e-4 // 2e-4\n\nvec4 texture(     sampler2D   s, vec2 c)                   { return texture2D(s,c); }\nvec4 texture(     sampler2D   s, vec2 c, float b)          { return texture2D(s,c,b); }\nvec4 texture(     samplerCube s, vec3 c )                  { return textureCube(s,c); }\nvec4 texture(     samplerCube s, vec3 c, float b)          { return textureCube(s,c,b); }\nfloat round( float x ) { return floor(x+0.5); }\nvec2 round(vec2 x) { return floor(x + 0.5); }\nvec3 round(vec3 x) { return floor(x + 0.5); }\nvec4 round(vec4 x) { return floor(x + 0.5); }\nfloat trunc( float x, float n ) { return floor(x*n)/n; }\nmat3 transpose(mat3 m) { return mat3(m[0].x, m[1].x, m[2].x, m[0].y, m[1].y, m[2].y, m[0].z, m[1].z, m[2].z); }\nfloat determinant( in mat2 m ) { return m[0][0]*m[1][1] - m[0][1]*m[1][0]; }\nfloat determinant( mat4 m ) { float b00 = m[0][0] * m[1][1] - m[0][1] * m[1][0], b01 = m[0][0] * m[1][2] - m[0][2] * m[1][0], b02 = m[0][0] * m[1][3] - m[0][3] * m[1][0], b03 = m[0][1] * m[1][2] - m[0][2] * m[1][1], b04 = m[0][1] * m[1][3] - m[0][3] * m[1][1], b05 = m[0][2] * m[1][3] - m[0][3] * m[1][2], b06 = m[2][0] * m[3][1] - m[2][1] * m[3][0], b07 = m[2][0] * m[3][2] - m[2][2] * m[3][0], b08 = m[2][0] * m[3][3] - m[2][3] * m[3][0], b09 = m[2][1] * m[3][2] - m[2][2] * m[3][1], b10 = m[2][1] * m[3][3] - m[2][3] * m[3][1], b11 = m[2][2] * m[3][3] - m[2][3] * m[3][2];  return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;}\nmat2 inverse(mat2 m) { float det = determinant(m); return mat2(m[1][1], -m[0][1], -m[1][0], m[0][0]) / det; }\nmat4 inverse(mat4 m ) { float inv0 = m[1].y*m[2].z*m[3].w - m[1].y*m[2].w*m[3].z - m[2].y*m[1].z*m[3].w + m[2].y*m[1].w*m[3].z + m[3].y*m[1].z*m[2].w - m[3].y*m[1].w*m[2].z; float inv4 = -m[1].x*m[2].z*m[3].w + m[1].x*m[2].w*m[3].z + m[2].x*m[1].z*m[3].w - m[2].x*m[1].w*m[3].z - m[3].x*m[1].z*m[2].w + m[3].x*m[1].w*m[2].z; float inv8 = m[1].x*m[2].y*m[3].w - m[1].x*m[2].w*m[3].y - m[2].x  * m[1].y * m[3].w + m[2].x  * m[1].w * m[3].y + m[3].x * m[1].y * m[2].w - m[3].x * m[1].w * m[2].y; float inv12 = -m[1].x  * m[2].y * m[3].z + m[1].x  * m[2].z * m[3].y +m[2].x  * m[1].y * m[3].z - m[2].x  * m[1].z * m[3].y - m[3].x * m[1].y * m[2].z + m[3].x * m[1].z * m[2].y; float inv1 = -m[0].y*m[2].z * m[3].w + m[0].y*m[2].w * m[3].z + m[2].y  * m[0].z * m[3].w - m[2].y  * m[0].w * m[3].z - m[3].y * m[0].z * m[2].w + m[3].y * m[0].w * m[2].z; float inv5 = m[0].x  * m[2].z * m[3].w - m[0].x  * m[2].w * m[3].z - m[2].x  * m[0].z * m[3].w + m[2].x  * m[0].w * m[3].z + m[3].x * m[0].z * m[2].w - m[3].x * m[0].w * m[2].z; float inv9 = -m[0].x  * m[2].y * m[3].w +  m[0].x  * m[2].w * m[3].y + m[2].x  * m[0].y * m[3].w - m[2].x  * m[0].w * m[3].y - m[3].x * m[0].y * m[2].w + m[3].x * m[0].w * m[2].y; float inv13 = m[0].x  * m[2].y * m[3].z - m[0].x  * m[2].z * m[3].y - m[2].x  * m[0].y * m[3].z + m[2].x  * m[0].z * m[3].y + m[3].x * m[0].y * m[2].z - m[3].x * m[0].z * m[2].y; float inv2 = m[0].y  * m[1].z * m[3].w - m[0].y  * m[1].w * m[3].z - m[1].y  * m[0].z * m[3].w + m[1].y  * m[0].w * m[3].z + m[3].y * m[0].z * m[1].w - m[3].y * m[0].w * m[1].z; float inv6 = -m[0].x  * m[1].z * m[3].w + m[0].x  * m[1].w * m[3].z + m[1].x  * m[0].z * m[3].w - m[1].x  * m[0].w * m[3].z - m[3].x * m[0].z * m[1].w + m[3].x * m[0].w * m[1].z; float inv10 = m[0].x  * m[1].y * m[3].w - m[0].x  * m[1].w * m[3].y - m[1].x  * m[0].y * m[3].w + m[1].x  * m[0].w * m[3].y + m[3].x * m[0].y * m[1].w - m[3].x * m[0].w * m[1].y; float inv14 = -m[0].x  * m[1].y * m[3].z + m[0].x  * m[1].z * m[3].y + m[1].x  * m[0].y * m[3].z - m[1].x  * m[0].z * m[3].y - m[3].x * m[0].y * m[1].z + m[3].x * m[0].z * m[1].y; float inv3 = -m[0].y * m[1].z * m[2].w + m[0].y * m[1].w * m[2].z + m[1].y * m[0].z * m[2].w - m[1].y * m[0].w * m[2].z - m[2].y * m[0].z * m[1].w + m[2].y * m[0].w * m[1].z; float inv7 = m[0].x * m[1].z * m[2].w - m[0].x * m[1].w * m[2].z - m[1].x * m[0].z * m[2].w + m[1].x * m[0].w * m[2].z + m[2].x * m[0].z * m[1].w - m[2].x * m[0].w * m[1].z; float inv11 = -m[0].x * m[1].y * m[2].w + m[0].x * m[1].w * m[2].y + m[1].x * m[0].y * m[2].w - m[1].x * m[0].w * m[2].y - m[2].x * m[0].y * m[1].w + m[2].x * m[0].w * m[1].y; float inv15 = m[0].x * m[1].y * m[2].z - m[0].x * m[1].z * m[2].y - m[1].x * m[0].y * m[2].z + m[1].x * m[0].z * m[2].y + m[2].x * m[0].y * m[1].z - m[2].x * m[0].z * m[1].y; float det = m[0].x * inv0 + m[0].y * inv4 + m[0].z * inv8 + m[0].w * inv12; det = 1.0 / det; return det*mat4( inv0, inv1, inv2, inv3,inv4, inv5, inv6, inv7,inv8, inv9, inv10, inv11,inv12, inv13, inv14, inv15);}\nfloat sinh(float x)  { return (exp(x)-exp(-x))/2.; }\nfloat cosh(float x)  { return (exp(x)+exp(-x))/2.; }\nfloat tanh(float x)  { return sinh(x)/cosh(x); }\nfloat coth(float x)  { return cosh(x)/sinh(x); }\nfloat sech(float x)  { return 1./cosh(x); }\nfloat csch(float x)  { return 1./sinh(x); }\nfloat asinh(float x) { return    log(x+sqrt(x*x+1.)); }\nfloat acosh(float x) { return    log(x+sqrt(x*x-1.)); }\nfloat atanh(float x) { return .5*log((1.+x)/(1.-x)); }\nfloat acoth(float x) { return .5*log((x+1.)/(x-1.)); }\nfloat asech(float x) { return    log((1.+sqrt(1.-x*x))/x); }\nfloat acsch(float x) { return    log((1.+sqrt(1.+x*x))/x); }\nvec4 textureLod(  sampler2D   s, vec2 c, float b)          { return texture2DLodEXT(s,c,b); }\nvec4 textureGrad( sampler2D   s, vec2 c, vec2 dx, vec2 dy) { return texture2DGradEXT(s,c,dx,dy); }\n// clang-format on\n\n//#define cloud2\n\n// Performance\nconst int steps = 16;  // 16 is fast, 128 or 256 is extreme high\nconst int stepss = 16; // 16 is fast, 16 or 32 is high\n\n// Environment\nconst float R0 = 6360e3; // planet radius //6360e3 actual 6371km\nconst float Ra = 6380e3; // atmosphere radius //6380e3 troposphere 8 to 14.5km\nconst float I = 10.;     // sun light power, 10.0 is normal\nconst float SI = 5.;     // sun intensity for sun\nconst float g = 0.45;    // light concentration .76 //.45 //.6  .45 is normaL\nconst float g2 = g * g;\nconst float PI = 3.14159265358979323846;\nconst float PI2 = 2. * 3.14159265358979323846;\n\nconst float ts = (cameraheight / 2.5e5);\n\nconst float s = 0.999; // light concentration for sun\n#if SOFT_SUN\nconst float s2 = s;\n#else\nconst float s2 = s * s;\n#endif\nconst float Hr = 8e3;   // Rayleigh scattering top //8e3\nconst float Hm = 1.2e3; // Mie scattering top //1.3e3\n\nvec3 bM = vec3(21e-6); // normal mie // vec3(21e-6)\n// vec3 bM = vec3(50e-6); //high mie\n\n// Rayleigh scattering (sky color, atmospheric up to 8km)\nvec3 bR = vec3(5.8e-6, 13.5e-6, 33.1e-6); // normal earth\n// vec3 bR = vec3(5.8e-6, 33.1e-6, 13.5e-6); //purple\n// vec3 bR = vec3( 63.5e-6, 13.1e-6, 50.8e-6 ); //green\n// vec3 bR = vec3( 13.5e-6, 23.1e-6, 115.8e-6 ); //yellow\n// vec3 bR = vec3( 5.5e-6, 15.1e-6, 355.8e-6 ); //yeellow\n// vec3 bR = vec3(3.5e-6, 333.1e-6, 235.8e-6 ); //red-purple\n\nvec3 C = vec3(0., -R0, 0.);             // planet center\nvec3 Ds = normalize(vec3(0., 0., -1.)); // sun direction?\n\nfloat cloudyhigh = 0.05; // if cloud2 defined\n\n#if ORIG_CLOUD\nfloat cloudnear =\n    1.0; // 9e3 12e3  //do not render too close clouds on the zenith\nfloat cloudfar = 1e3; // 15e3 17e3\n#else\nfloat cloudnear = 1.0; // 15e3 17e3\nfloat cloudfar = 70e3; // 160e3  //do not render too close clouds on the horizon\n                       // 160km should be max for cumulus\n#endif\n\n// AURORA STUFF\nmat2 mm2(in float a) {\n  float c = cos(a);\n  float s = sin(a);\n  return mat2(c, s, -s, c);\n}\n\nmat2 m2 = mat2(0.95534, 0.29552, -0.29552, 0.95534);\n\nfloat tri(in float x) { return clamp(abs(fract(x) - .5), 0.01, 0.49); }\n\nvec2 tri2(in vec2 p) { return vec2(tri(p.x) + tri(p.y), tri(p.y + tri(p.x))); }\n\nfloat triNoise2d(in vec2 p, float spd) {\n  float z = 1.8;\n  float z2 = 2.5;\n  float rz = 0.;\n  p *= mm2(p.x * 0.06);\n  vec2 bp = p;\n  for (float i = 0.; i < 5.; i++) {\n    vec2 dg = tri2(bp * 1.85) * .75;\n    dg *= mm2(t * spd);\n    p -= dg / z2;\n\n    bp *= 1.3;\n    z2 *= 1.45;\n    z *= .42;\n    p *= 1.21 + (rz - 1.0) * .02;\n\n    rz += tri(p.x + tri(p.y)) * z;\n    p *= -m2;\n  }\n  return clamp(1. / pow(rz * 29., 1.3), 0., .55);\n}\n\nfloat hash21(in vec2 n) {\n  return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\nvec4 aurora(vec3 ro, vec3 rd) {\n  vec4 col = vec4(0);\n  vec4 avgCol = vec4(0);\n  ro *= 1e-5;\n  float mt = 10.;\n  for (float i = 0.; i < 5.; i++) {\n    float of = 0.006 * hash21(gl_FragCoord.xy) * smoothstep(0., 15., i * mt);\n    float pt = ((.8 + pow((i * mt), 1.2) * .001) - rd.y) / (rd.y * 2. + 0.4);\n    pt -= of;\n    vec3 bpos = (ro) + pt * rd;\n    vec2 p = bpos.zx;\n    // vec2 p = rd.zx;\n    float rzt = triNoise2d(p, 0.1);\n    vec4 col2 = vec4(0, 0, 0, rzt);\n    col2.rgb =\n        (sin(1. - vec3(2.15, -.5, 1.2) + (i * mt) * 0.053) * (0.5 * mt)) * rzt;\n    avgCol = mix(avgCol, col2, .5);\n    col += avgCol * exp2((-i * mt) * 0.04 - 2.5) * smoothstep(0., 5., i * mt);\n  }\n\n  col *= (clamp(rd.y * 15. + .4, 0., 1.2));\n  return col * 2.8;\n}\n\n// END AURORA STUFF\n\nfloat noise(in vec2 v) {\n  return 0.5;\n  //    texture(iChannel0,(v+.5)/256., 0.).r * 0.01;\n}\n\n// by iq\nfloat Noise(in vec3 x) {\n  vec3 p = floor(x);\n  vec3 f = fract(x);\n  f = f * f * (3.0 - 2.0 * f);\n\n  vec2 uv = (p.xy + vec2(37.0, 17.0) * p.z) + f.xy;\n  vec2 rg = textureLod(iChannel0, (uv + 0.5) / 256.0, -100.0).yx;\n  return mix(rg.x, rg.y, f.z);\n}\n\nfloat fnoise(vec3 p, in float t) {\n  p *= .25;\n  float f;\n\n  f = 0.5000 * Noise(p);\n  p = p * 3.02;\n  p.y -= t * .1; // t*.05 speed cloud changes\n  f += 0.2500 * Noise(p);\n  p = p * 3.03;\n  p.y += t * .06;\n  f += 0.1250 * Noise(p);\n  p = p * 3.01;\n  f += 0.0625 * Noise(p);\n  p = p * 3.03;\n  f += 0.03125 * Noise(p);\n  p = p * 3.02;\n  f += 0.015625 * Noise(p);\n  return f;\n}\n\nfloat cloud(vec3 p, in float t) {\n  float cld = fnoise(p * cloudnoise, t) + cloudy * 0.1;\n  cld = smoothstep(.4 + .04, .6 + .04, cld);\n  cld *= cld * (5.0 * rainmulti);\n  return cld + haze;\n}\n\nvoid densities(in vec3 pos, out float rayleigh, out float mie) {\n  float h = length(pos - C) - R0;\n  rayleigh = exp(-h / Hr);\n  vec3 d = pos;\n  d.y = 0.0;\n  float dist = length(d);\n\n  float cld = 0.;\n  if (mincloudheight < h && h < maxcloudheight) {\n    // cld = cloud(pos+vec3(t*1e3,0., t*1e3),t)*cloudy;\n    cld = cloud(pos + vec3(xaxiscloud, yaxiscloud, zaxiscloud), t) *\n          cloudy; // direction and speed the cloud movers\n    cld *= sin(3.1415 * (h - mincloudheight) / mincloudheight) * cloudy;\n  }\n#ifdef cloud2\n  float cld2 = 0.;\n  if (12e3 < h && h < 15.5e3) {\n    cld2 = fnoise(pos * 3e-4, t) *\n           cloud(pos * 32.0 + vec3(27612.3, 0., -t * 15e3), t);\n    cld2 *= sin(3.1413 * (h - 12e3) / 12e3) * cloudyhigh;\n    cld2 = clamp(cld2, 0.0, 1.0);\n  }\n\n#endif\n\n#if ORIG_CLOUD\n  if (dist < cloudfar) {\n    float factor =\n        clamp(1.0 - ((cloudfar - dist) / (cloudfar - cloudnear)), 0.0, 1.0);\n    cld *= factor;\n  }\n#else\n\n  if (dist > cloudfar) {\n\n    float factor =\n        clamp(1.0 - ((dist - cloudfar) / (cloudfar - cloudnear)), 0.0, 1.0);\n    cld *= factor;\n  }\n#endif\n\n  mie = exp(-h / Hm) + cld + haze;\n#ifdef cloud2\n  mie += cld2;\n#endif\n}\n\nfloat escape(in vec3 p, in vec3 d, in float R) {\n  vec3 v = p - C;\n  float b = dot(v, d);\n  float c = dot(v, v) - R * R;\n  float det2 = b * b - c;\n  if (det2 < 0.)\n    return -1.;\n  float det = sqrt(det2);\n  float t1 = -b - det, t2 = -b + det;\n  return (t1 >= 0.) ? t1 : t2;\n}\n\n// this can be explained:\n// http://www.scratchapixel.com/lessons/3d-advanced-lessons/simulating-the-colors-of-the-sky/atmospheric-scattering/\nvoid scatter(vec3 o, vec3 d, out vec3 col, out vec3 scat, in float t) {\n\n  float L = escape(o, d, Ra);\n  float mu = dot(d, Ds);\n  float opmu2 = 1. + mu * mu;\n  float phaseR = .0596831 * opmu2;\n  float phaseM = .1193662 * (1. - g2) * opmu2 /\n                 ((2. + g2) * pow(1. + g2 - 2. * g * mu, 1.5));\n  float phaseS = .1193662 * (1. - s2) * opmu2 /\n                 ((2. + s2) * pow(1. + s2 - 2. * s * mu, 1.5));\n\n  float depthR = 0., depthM = 0.;\n  vec3 R = vec3(0.), M = vec3(0.);\n\n  float dl = L / float(steps);\n  for (int i = 0; i < steps; ++i) {\n    float l = float(i) * dl;\n    vec3 p = (o + d * l);\n\n    float dR, dM;\n    densities(p, dR, dM);\n    dR *= dl;\n    dM *= dl;\n    depthR += dR;\n    depthM += dM;\n\n    float Ls = escape(p, Ds, Ra);\n    if (Ls > 0.) {\n      float dls = Ls / float(stepss);\n      float depthRs = 0., depthMs = 0.;\n      for (int j = 0; j < stepss; ++j) {\n        float ls = float(j) * dls;\n        vec3 ps = (p + Ds * ls);\n        float dRs, dMs;\n        densities(ps, dRs, dMs);\n        depthRs += dRs * dls;\n        depthMs += dMs * dls;\n      }\n\n      vec3 A = exp(-(bR * (depthRs + depthR) + bM * (depthMs + depthM)));\n      R += (A * dR);\n      M += A * dM;\n    } else {\n    }\n  }\n\n  // col = (I) * (R * bR * phaseR + M * bM * (phaseM ));\n  col = (I) * (M * bM * (phaseM)); // Mie scattering\n#if NICE_HACK_SUN\n  col += (SI) * (M * bM * phaseS); // Sun\n#endif\n  col += (I) * (R * bR * phaseR); // Rayleigh scattering\n  scat = 0.1 * (bM * depthM);\n  // scat = 0.0 + clamp(depthM*5e-7,0.,1.);\n}\n\nvec3 hash33(vec3 p) {\n  p = fract(p * vec3(443.8975, 397.2973, 491.1871));\n  p += dot(p.zxy, p.yxz + 19.27);\n  return fract(vec3(p.x * p.y, p.z * p.x, p.y * p.z));\n}\n\nvec3 stars(in vec3 p) {\n  vec3 c = vec3(0.);\n  float res = iResolution.x * 2.5;\n\n  for (float i = 0.; i < 4.; i++) {\n    vec3 q = fract(p * (.15 * res)) - 0.5;\n    vec3 id = floor(p * (.15 * res));\n    vec2 rn = hash33(id).xy;\n    float c2 = 1. - smoothstep(0., .6, length(q));\n    c2 *= step(rn.x, .0005 + i * i * 0.001);\n    c +=\n        c2 * (mix(vec3(1.0, 0.49, 0.1), vec3(0.75, 0.9, 1.), rn.y) * 0.1 + 0.9);\n    p *= 1.3;\n  }\n  return c * c * .8;\n}\n\n// SIMPLE SUN STUFF\nconst float density = 0.5;\nconst float zenithOffset = 0.48;\nconst vec3 skyColor = vec3(0.37, 0.55, 1.0) * (1.0 + 0.0);\n\n#define zenithDensity(x) density / pow(max(x - zenithOffset, 0.0035), 0.75)\n\nfloat getSunPoint(vec2 p, vec2 lp) {\n  return smoothstep(0.04 * (fov / 2.0), 0.026 * (fov / 2.0), distance(p, lp)) *\n         50.0;\n}\n\nfloat getMie(vec2 p, vec2 lp) {\n  float mytest = lp.y < 0.5 ? (lp.y + 0.5) * pow(0.05, 20.0) : 0.05;\n  float disk = clamp(1.0 - pow(distance(p, lp), mytest), 0.0, 1.0);\n  return disk * disk * (3.0 - 2.0 * disk) * 0.25 * PI;\n}\n\nvec3 getSkyAbsorption(vec3 x, float y) {\n  vec3 absorption = x * y;\n  absorption = pow(absorption, 1.0 - (y + absorption) * 0.5) / x / y;\n  return absorption;\n}\n\nvec3 jodieReinhardTonemap(vec3 c) {\n  float l = dot(c, vec3(0.2126, 0.7152, 0.0722));\n  vec3 tc = c / (c + 1.0);\n  return mix(c / (l + 1.0), tc, tc);\n}\n\nvec3 getAtmosphericScattering(vec2 p, vec2 lp) {\n  float zenithnew = zenithDensity(p.y);\n  float sunPointDistMult =\n      clamp(length(max(lp.y + 0.1 - zenithOffset, 0.0)), 0.0, 1.0);\n  vec3 absorption = getSkyAbsorption(skyColor, zenithnew);\n  vec3 sunAbsorption = getSkyAbsorption(skyColor, zenithDensity(lp.y + 0.1));\n  vec3 sun3 = getSunPoint(p, lp) * absorption;\n  vec3 mie2 = getMie(p, lp) * sunAbsorption;\n  vec3 totalSky = sun3; //+ mie2;\n  totalSky *= sunAbsorption * 0.5 + 0.5 * length(sunAbsorption);\n  vec3 newSky = jodieReinhardTonemap(totalSky);\n  return newSky;\n}\n// END SIMPLE SUN STUFF\n\n// RAIN STUFF\nvec3 N31(float p) {\n  //  3 out, 1 in... DAVE HOSKINS\n  vec3 p3 = fract(vec3(p) * vec3(.1031, .11369, .13787));\n  p3 += dot(p3, p3.yzx + 19.19);\n  return fract(\n      vec3((p3.x + p3.y) * p3.z, (p3.x + p3.z) * p3.y, (p3.y + p3.z) * p3.x));\n}\n\nfloat SawTooth(float t) {\n  return cos(t + cos(t)) + sin(2. * t) * .2 + sin(4. * t) * .02;\n}\n\nfloat DeltaSawTooth(float t) {\n  return 0.4 * cos(2. * t) + 0.08 * cos(4. * t) -\n         (1. - sin(t)) * sin(t + cos(t));\n}\n\nvec2 GetDrops(vec2 uv, float seed, float m) {\n\n  float t2 = t + m;\n  vec2 o = vec2(0.);\n\n#ifndef DROP_DEBUG\n  uv.y += t2 * .05;\n#endif\n\n  uv *= vec2(10., 2.5) * 2.;\n  vec2 id = floor(uv);\n  vec3 n = N31(id.x + (id.y + seed) * 546.3524);\n  vec2 bd = fract(uv);\n\n  vec2 uv2 = bd;\n\n  bd -= 0.5;\n\n  bd.y *= 4.;\n\n  bd.x += (n.x - .5) * rainy;\n\n  t2 += n.z * 6.28;\n  float slide = SawTooth(t2);\n\n  float ts = 1.5;\n  vec2 trailPos = vec2(bd.x * ts, (fract(bd.y * ts * 2. - t2 * 2.) - .5) * .5);\n\n  bd.y += slide * 2.; // make drops slide down\n\n#ifdef HIGH_QUALITY\n  float dropShape = bd.x * bd.x;\n  dropShape *= DeltaSawTooth(t);\n  bd.y += dropShape; // change shape of drop when it is falling\n#endif\n\n  float d = length(bd); // distance to main drop\n\n  float trailMask = S(-.2, .2, bd.y); // mask out drops that are below the main\n  trailMask *= bd.y;                  // fade dropsize\n  float td = length(trailPos * max(.5, trailMask)); // distance to trail drops\n\n  float mainDrop = S(.2, .1, d);\n  float dropTrail = S(.1, .02, td);\n\n  dropTrail *= trailMask;\n  o = mix(bd * mainDrop, trailPos, dropTrail); // mix main drop and drop trail\n\n#ifdef DROP_DEBUG\n  if (uv2.x < .02 || uv2.y < .01)\n    o = vec2(1.);\n#endif\n\n  return o;\n}\n// END RAIN STUFF\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n  float AR = iResolution.x / iResolution.y;\n  float M = 1.0; // canvas.innerWidth/M //canvas.innerHeight/M --res\n  // vec2 circle = vec2(cos(gameTime* PI2), sin(gameTime*PI2));\n  vec2 circle = vec2(1.0) + vec2(sin(-gameTime * PI2), cos(gameTime * PI2));\n  circle *= 0.5;\n  // circle.x = iResolution.x/2.;\n  // circle.y = circle.;\n  vec2 uvMouse = circle;\n  // / iResolution.xy);\n  // uvMouse.x *= AR;\n\n  vec2 uv0 = (fragCoord.xy / iResolution.xy);\n  uv0 *= M;\n  // uv0.x *= AR;\n\n  vec2 uv = uv0 * (2.0 * M) - (1.0 * M);\n  uv.x *= AR;\n\n  // uvMouse.y=(0.7-(0.05*fov)); //initial view\n  // uvMouse.x=(1.0-(0.05*fov)); //initial view\n  // circle+=0.5;\n  // uvMouse.xy = circle - vec2((0.05*fov));\n  // uvMouse.xy = vec2(1.0, 0.5);\n  // uvMouse*= 100.;\n  // uvMouse += iResolution.xy *0.5;\n  Ds = normalize(vec3(uvMouse.x - ((0.5 * AR)), uvMouse.y - 0.5, (fov / -2.0)));\n\n  vec3 O = vec3(0., cameraheight, 0.);\n  vec3 D = normalize(vec3(uv, -(fov * M)));\n\n  vec3 color = vec3(0.);\n  vec3 scat = vec3(0.);\n\n  // float scat = 0.;\n  float att = 1.;\n  float staratt = 1.;\n  float scatatt = 1.;\n  vec3 star = vec3(0.);\n  vec4 aur = vec4(0.);\n\n  float fade = smoothstep(0., 0.01, abs(D.y)) * 0.5 + 0.9;\n\n  staratt = 1. - min(1.0, (uvMouse.y * 2.0));\n  scatatt = 1. - min(1.0, (uvMouse.y * 2.2));\n\n  if (D.y < -ts) {\n    float L = -O.y / D.y;\n    O = O + D * L;\n    D.y = -D.y;\n    D = normalize(\n        D +\n        vec3(0, .003 * sin(t + 6.2831 * noise(O.xz + vec2(0., -t * 1e3))), 0.));\n    att = .6;\n    star = stars(D);\n    uvMouse.y < 0.5 ? aur = smoothstep(0.0, 2.5, aurora(O, D)) : aur = aur;\n  } else {\n    float L1 = O.y / D.y;\n    vec3 O1 = O + D * L1;\n\n    vec3 D1 = vec3(1.);\n    D1 = normalize(\n        D + vec3(1.,\n                 0.0009 * sin(t + 6.2831 * noise(O1.xz + vec2(0., t * 0.8))),\n                 0.));\n    star = stars(D1);\n    uvMouse.y < 0.5 ? aur = smoothstep(0., 1.5, aurora(O, D)) *fade : aur = aur;\n  }\n\n  star *= att;\n  star *= staratt;\n\n  scatter(O, D, color, scat, t);\n  color *= att;\n  scat *= att;\n  scat *= scatatt;\n\n// draw the badly implemented sun\n#if SIMPLE_SUN\n\n  vec2 uv1 = (fragCoord.xy / iResolution.xy);\n  uv1 *= M;\n  uv1.x *= AR;\n\n  vec3 sun2 = getAtmosphericScattering(uv1, vec2(uvMouse.x, uvMouse.y));\n  color += sun2;\n#endif\n\n  color += scat;\n  color += star;\n  //   color=color*(1.-(aur.a)*scatatt) + (aur.rgb*scatatt);\n  color += aur.rgb * scatatt;\n\n#if ENABLE_RAIN\n  vec2 drops = vec2(0.);\n  if (rainmulti > 1.0) {\n    drops = GetDrops(uv / 2.0, 1., 1.);\n\n    color += drops.x + drops.y;\n  }\n#endif\n\n  // float env = pow( smoothstep(.5, iResolution.x / iResolution.y,\n  // length(uv*0.8)), 0.0);\n  fragColor = vec4(pow(color, vec3(1.0 / 2.2)), 1.); // gamma correct\n}\nvoid main() {\n  vec4 color = vec4(0.0);\n  mainImage(color, gl_FragCoord.xy);\n  gl_FragColor = color;\n}\n"},5:function(n,e,t){"use strict";var a=t.w[n.i];n.exports=a;t(3);a.v()}}]);
//# sourceMappingURL=2.67f38ccd96cdc3e537c3.js.map